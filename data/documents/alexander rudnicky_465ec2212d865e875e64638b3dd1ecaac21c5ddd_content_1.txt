Title: Transformer Working Memory Enables Regular Language Reasoning And Natural Language Length Extrapolation
Authors: Ta-Chung Chi, Ting-Han Fan, Alexander I. Rudnicky, Peter J. Ramadge
Section: C Proof of Lemma 1
range ( n ) : f o r k in range ( n ) : W1[ i *n+k , i *n2+ j *n+k ] = 1 W1[ n2+k*n+ j , i *n2+ j *n+k ] = 1 re turn W1 def get_W2 ( n ) : eye = np . eye ( n*n , d t y p e = i n t ) ones = np . ones ( ( n , 1 ) , d t y p e = i n t ) W2 = np . kron ( eye , ones ) re turn W2 get_W1(2) gives: [ [ 1 0 1 0 0 0 0 0] [0 1 0 1 0 0 0 0] [0 0 0 0 1 0 1 0] [0 0 0 0 0 1 0 1] [1 0 0 0 1 0 0 0] [0 0 1 0 0 0 1 0] [0 1 0 0 0 1 0 0] [0 0 0 1 0 0 0 1 ] ] get_W2(2) gives: [ [ 1 0 0 0] [1 0 0 0] [0 1 0 0] [0 1 0 0] [0 0 1 0] [0 0 1 0] [0 0 0 1] [0 0 0 1 ] ] D.2 An Illustrative Example for n = 2 Suppose the input matrices are: A = [ 1 0 1 0 ] , B = [ 0 1 1 0 ] . The concatenated flattened input becomes: x = [Flat(A),Flat(B)] = [1 0 1 0 0 1 1 0]. Then, Lemma 1 is verified as follows: ReLU ( xW (1) − 1>n3 ) W (2) =ReLU ([1 1 2 0 1 1 2 0]− 1)W (2) =[0 0 1 0 0 0 1 0]W (2) =[0 1 0 1] =Flat ([ 0 1 0 1 ]) = Flat (AB) . Here is the Python code for the above example: A = np . a r r a y ( [ [ 1 , 0 ] , [ 1 , 0 ] ] ) . r e s h a p e ( −1) B = np . a r r a y ( [ [ 0 , 1 ] , [ 1 , 0 ] ] ) . r e s h a p e ( −1) x = np . c o n c a t e n a t e ( [ A, B ] ) . r e s h a p e (1 , −1 ) W1 = get_W1 (