Title: Overview of the TREC 2021 Fair Ranking Track
Authors: Michael D. Ekstrand, Graham McDonald
Section: 56 0.008593 0.124741 0.009902 0.000342 0.000587 0.015458 0.001078
148 0.018613 0.025322 0.006099 149 0.040886 0.073876 0.036999 150 0.042203 0.116868 0.025218 [106 rows x 8 columns] This is our group exposure target distributions for each query, for the geographic data. We’re now ready to set up the matrix. train geo qtgt = q geo tgt.loc[train topics['id']] eval geo qtgt = q geo tgt.loc[eval topics['id']] t2 train geo metric = metrics.Task2Metric(train qrels.set index('id'), page geo align, page work, train geo qtgt) binpickle.dump(t2 train geo metric, 'task2-train-geo-metric.bpk', codec=codec) INFO:binpickle.write:pickled 2018 bytes with 9 buffers t2 eval geo metric = metrics.Task2Metric(eval qrels.set index('id'), page geo align, page work, eval geo qtgt) binpickle.dump(t2 eval geo metric, 'task2-eval-geo-metric.bpk', codec=codec) INFO:binpickle.write:pickled 2014 bytes with 9 buffers A.6.3 Intersectional Alignment Now we need to compute the intersectional targets for Task 2. We’re going to take a slightly different approach here, based on the intersectional logic for Task 1, because we’ve come up with better ways to write the code, but the effect is the same: only known aspects are averaged. We’ll write a function very similar to the one for Task 1: def query xideal(qdf, ravel=True): pages = qdf['page id'] pages = pages[pages.isin(page xalign.indexes['page'])] q xa = page xalign.loc[pages.values, :, :] # now we need to get the exposure for the pages, and multiply p exp = qp exp.loc[qdf.name] assert p exp.index.is unique p exp = xr.DataArray(p exp, dims=['page']) # and we multiply! q xa = q xa * p exp # normalize into a matrix (this time we don't clear) q am = q xa.sum(axis=0) q am = q am / q am.sum() # compute fractions in each section - combined with q am[0,0], this should be about 1 q fk all = q am[1:, 1:].sum() q fk geo = q am[1:, :1].sum() q fk gen = q am[:1, 1:].sum() # known average q am[1:, 1:] *= 0.5 q am[1:, 1:] += int tgt * 0.5 * q fk all # known-geo average q am[1:, :1] *= 0.5 q am[1:, :1] += geo tgt xa * 0.5 * q fk geo # known-gender average q am[:1, 1:] *= 0.5 q am[:1, 1:] += gender tgt xa * 0.5 * q fk gen # and return the result if ravel: return pd.Series(q am.values.ravel()) else: return q am Test this function out: query xideal(qdf, ravel=False) <xarray.DataArray (geography: 8, gender: 4)> array([[5.40211229e-01, 1.22904624e-02, 2.26610467e-02, 1.75635724e-04], [3.80909493e-02, 2.90804953e-03, 2.59344827e-03, 4.25392005e-05], [2.85527900e-08, 2.09691080e-09, 2.09691080e-09, 4.23618344e-11], [1.34695670e-01, 8.88355123e-03, 1.01072347e-02, 1.64648516e-04], [8.71895859e-02, 2.97387866e-03, 8.25814408e-03, 2.84372324e-05], [2.16878846e-02, 1.67819032e-03, 1.65196427e-03, 2.36185304e-05], [5.32652519e-02, 2.51534798e-03, 9.59370956e-03, 1.36109402e-05], [3.48679417e-02, 4.71346052e-04, 2.95512391e-03, 1.46710935e-06]]) Coordinates: * geography (geography) object